
协议：
	双方在进行数据传递过程中遵守一组规则。

	ftp、http、tcp、udp、arp、rarp、ip...

分层模型：

	OSI七层： 物、数、网、传、会、表、应	―― 理论

	TCP/IP四层：链、网、传、应	―― 实际

	分层目的，减少层与层之间数据传递的耦合关系。

各层作用：

	链路层：  
		源mac ―― 目的mac

		【了解】借助 ARP 协议。 通过 Ip ―― mac 地址。(通过广播数据包的方式,目标mac接收到数据包之后会回发数据包,从而拿到目标mac地址

		之所以这样做是因为以太网规定数据不能从一个ip到另一个ip,只能从一块网卡到另一块网卡,所以需要网卡地址,即mac地址)

	网络层：
		源IP ―― 目的IP

		IP地址：唯一标识 一台主机 网络身份

	传输层:
		源 port ―― 目的 port

		port：网络环境中， 在一台主机上，唯一标识一个  进程身份。

		-----总结： IP + port ： 在网络环境中，唯一标识一个进程。 ―― socket通信手段。

	应用层：（不是必须的）

		数据封装 ―― 数据解封装

网络数据通信过程：【重点】

	封装： 数据 ――> 应用层（可选）――> 传输层（必须）――> 网络层（必须）――> 链路层 ――> 网卡
		
	封装后的数据，才能进入网络环境（以太网）中，传输。

	解封装：	网卡 ――> 解链路层 ――> 解网络层 ――> 解传输层 ――> 解应用层 ――> 数据

socket： 套接字（插座、插头）

	在一次“网络通信”过程中， socket必须是成对出现的。

	套接字：双向全双工通信。 ―― 既可以读、同时可以写。(包含一个读端和一个写端,类似于包含两个单向channel)

	常用socket分类:	1)流式socket,面向有链接的TCP	2)数据报式socket,面向无连接的UDP

网络应用设计模型：
			优点					缺点

	C/S：	缓存大量数据、协议选择灵活			工作量大、安全性较低、受平台影响。

	B/S:	工作量小、安全性较高、不受平台限制		不能缓冲大量数据、协议选择不灵活。网络应用支持受限。

TCP模型 ― CS架构 server：

	1. 创建监听套接字 net.Listen("通信协议"， “地址”) ――> 返回 监听套接字 listener

		通信协议： TCP、UDP ―― "tcp", "udp" 不支持大写

		地址： IP + port。 

			IP： 点分十进制的ip地址表现形式。4字节。  "192.168.66.23" ―― string

			port： 2 ^ 16: 不能超过  65535。  推荐 5000+  	8080浏览器用

	2. 使用listener 调用 Accept(）  阻塞监听客户端连接请求。

	    当 Accept() 返回时。说明已经成功与客户端建立连接。 返回用于“通信”的套接字。 conn

	3. 使用 conn 与客户端 读/写 进行数据通信。

		conn.read / conn.write

	4. 关闭 套接字 （监听、通信）

添加 netcat 工具 测试客户端：

	1. 解压 netcat-win32-1.12.zip 文件 到指定目录

	2. 拷贝 解压后目录，保存到环境变量： 

		方法：我的电脑-->属性-->高级系统设置-->环境变量-->系统变量中找“path”-->双击它-->新建-->粘贴

	3. 启动 cmd 执行 nc 命令 充当客户端测试

	4. nc 127.0.01 8004 （注意 IP 和 端口之间是“空格”）

	5. 输入 hello socket。 服务器应该能读到并向服务器的屏幕打印 “hello socket”


TCP模型 ― CS架构 client：

	1.  创建用于数据通信的套接字 net.Dial("传输协议"， “地址”) ――> 返回 通信套接字。 conn

		地址： IP + port。（服务器的 地址）

	2. 发送 /接收 数据给 服务器 

		conn.write()

	3. 关闭用于通信的套接字 

		conn.close()


TCP模型 ― CS架构 并发 server：

	1. 创建监听套接字 net.Listen("通信协议"， “地址”) ――> 返回 监听套接字 listener	

	2.  循环 监听客户端连接请求。 每当有一个客户端连接，返回一个通信套接字 conn， 并创建新子go程通信。

		for {
			conn = listener.Accept()	
	
			go HandlerConnect（conn）
		}

	3. 实现 HandlerConnect 

		1).  defer close

		2).  获取客户端  地址结构 （IP+Port）

			conn.RemoteAddr()
		for {

		        3)  读取客户端发送的数据

			conn.read()

		        4)  小写 转 大写
	
			strings.ToUpper()

		        5） 回写数据给客户端

			conn.write(）
		}

关闭连接：

	1. 服务器判断对端（客户端）关闭： 【重点！！！！】

		read --> 0 

		关闭本端，关闭套接字conn。

	2. 客户端发送“exit”请求关闭连接：

		服务器，正常读取。通过判断 buf 内容，关闭操作。

		通过 nc 发送来的命令额外包含‘\n’


















	

		

	
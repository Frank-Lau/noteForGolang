# 资源隔离、限流、降级、熔断

## 	1.资源隔离

​				1）为什么要使用资源隔离？

​						让系统中某一块东西，在故障的情况下，不会耗尽系统所有资源，比如某一块代码出现了死循环，导致同时启动了大量线程，导致系统崩溃，服务器上所有代码崩溃，所以需要设定线程池，最多只能起10个线程，不能再多了

## 	2.雪崩效应

​				服务之间存在链式反应调用关系，多个服务同时调用了核心服务A，而A由于某种故障导致迟迟没有返回，那么随着时间推移，上层资源逐渐耗尽，导致整个调用链条挂掉![截屏2020-10-20 05.32.10](/Users/xiaodong/Downloads/myNote/noteForGolang/高并发/assets/截屏2020-10-20 05.32.10.png)



​				解决方案：

​						1.引入超时机制：例如两秒钟超时，防止调用方资源耗尽

​						2.服务限流

​								1）信号量

​								2）线程池+队列

​						3.服务熔断 ：服务提供者不稳定时，请求10次失败了五次，会将其暂时关闭

​						4.服务降级：有熔断就一定会有降级，当某一个服务提供者进行熔断时，调用者本地进行其他的操作

​			hystrix熔断器：https://github.com/afex/hystrix-go

​			

```go
  	"github.com/afex/hystrix-go/hystrix"
	//服务熔断代码
	//第一步配置config
	configA:=hystrix.CommandConfig{
		Timeout:1000,//超时时间ms
		RequestVolumeThreshold:30,//请求多少次才会判断，默认20次
		ErrorPercentThreshold:20,//当请求30次，错误概率达到20%时启动熔断器，默认百分之50
		SleepWindow:50000,//过多长时间，熔断器再次检测是否开始，单位ms，默认5s
	}
	//第二步，配置conmmand
	hystrix.ConfigureCommand("aaaaa",configA)
	//第三步，使用do方法
	err:=hystrix.Do("aaaaa", func() error {
		//调用逻辑
		resp,err:= 实际服务
		return err
	}, func(e error) error {
		resp,err:= 降级逻辑
		return err
	})
	if err!=nil{
		返回错误信息
	}else {
		返回正确信息
	}

```

对于一个热门服务，会有多个其他服务直接或者间接调用，当服务提供者不能稳定提供服务时，例如出bug死循环，会导致调用者，资源消耗逐渐加大，最终导致调用链条崩溃，也就是雪崩，所以需要设置熔断器，有了熔断肯定有降级，例如超时时间为2s，超过2s之后会直接执行降级函数，再例如请求达到100次，并且失败概率达到百分之20，就会启动熔断器，直接执行降级函数，那熔断器启动之后并不能一直启动，如果一直启动和崩了也没啥区别了，所以需要设置熔断器启动时间，假设10s，10s之后会再次判断熔断器是否需要再次启动，如果这些参数都不设置，默认，请求20次，失败概率达到50%，熔断器启动5s